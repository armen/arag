===== Getting Started =====

==== Installation Instructions ====

=== Installing from SVN ===

1) Checkout a copy from SVN:
<code bash>
  svn checkout svn://svn.osp.ir/svnroot/arag/trunk arag  
</code>
2) Download third party libraries:
<code bash>
  ./arag/etc/scripts/get_third_party.sh
</code>

This command simply downloads and extracts the "CodeIgniter-1.5.4" and moves the system directory content to "libs/ci" then it downloads and extracts the "Smarty-2.6.18" and moves libs directory content to "libs/smarty".

3) Set "webapp/cache" directory to be writeable by your web server:
<code bash>
  chmod 777 arag/webapp/cache/
</code>

===== Arag Basics =====

==== Directory structure ====
These are the directories found at the root of the Arag project:

  +-- etc
  |    +-- scripts
  |
  +-- libs
  |    +-- smarty
  |    +-- ci
  |  
  +-- public_html
  |    +-- images
  |    +-- styles
  |    +-- index.php
  |
  +-- webapp
       +-- cache
       +-- components  
       +-- config
       +-- errors  
       +-- helpers 
       +-- hooks
       +-- libraries
       +-- models
       +-- modules
       +-- templates

In the following table you can find a brief introduction for some of these directories(for directories not listed below refer to the CodeIgniter  documentation):

^ Directory         ^ Description ^
| etc/scripts       | Contains bash or PHP scripts called from a command line. |
| libs              | Contains libraries which will be used in applications. At least it contains Smarty (/smarty) and CodeIgniter (/ci). |
| public_html       | Contains front controller, styles and images. In general it contains everything we need to send to end user client. |
| webapp/components | Contains Smarty components. |
| webapp/helpers    | Contains Smarty helper wrappers. |
| weabpp/libraries  | Contains Arag libraries which extends CodeIgneter libraries. | 
| webapp/modules    | Contains modules. |
| webapp/templates  | Contains global templates and Smarty plugins/configs. |

==== Arag configuration file ====
Arag configuration file is located at "webapp/configs/arag_configs.php". 
The major configurations are Smarty settings, you can enable or disable Smarty integration, change security settings add filters and etc.
There is also a config file in each module which hast the module's own configuration. To see where you can find this file refer to the [[#modules|modules]] section.

==== Arag Controllers ====
In Arag project has its own controller class which your controller should extends the parent controller class so that it can inherit all its functions.

For example:

  class MyController extends Arag_Controller
  {
     
  }

If you intend to use a constructor in any of your Controllers, you MUST place parent constructor call in custroctor as following example:

  class MyController extends Arag_Controller
  {
      function MyController()
      {
          parent::MyController();
      }     
  }

A new feature is implemented in Arag to make the naming and calling of a controller's methods very easy and understandable. By this way, Arag recognize when you call a function within a post or get method. so that if it is GET, it will call "<functionname>_read" and it will call "<functionname>_write" if it is POST. If none of them available, automatically it will call <"functionname>":

  function edit_write()
  {
    Statements
  }

  function edit_read()
  {
    Statement
  }

In the above example, if you load address "<controller>/edit", it will automatically call "edit_read". Cause it is a get method. And if you give a  HTML form an action of "<controller>/edit", it will load "edit_write", because it happens through a post method.\\
But remember that the raw function of "<functionname>", has more priority than "<functionname>_write" and "<functionname>_read". Take a look at the following codes:

  function edit()
  {
    Statements
  }

  function edit_write()
  {
    Statements
  }

  function edit_read()
  {
    Statement
  }

In these codes, always "edit" will be called, independent of you request method. 

==== Modules ====
In CodeIgniter we don't have Modules. Modules are implemented for Arag project.
Two major things you have to know about Arag modules: first there is an additional segment in URI that specified what modules should be executed and the second one is directory structure of modules.

In Arag there is no application directory, instead we have modules directory contains modules. 
Directory structure of modules could be something like this:

  +-- webapp
       ...
       +-- modules
            +-- <module_name>
            |      +-- config
            |      +-- controllers
            |      +-- locale
            |      +-- models
            |      +-- schemas
            |      +-- templates
            |
            +-- <module_name2>
                   +-- config
                   +-- controllers
                   +-- locale
                   +-- models
                   +-- schemas
                   +-- templates

For example the URI for first module specified in above structure, in the case of executing backend controller and post method is: "/<module_name>/backend/post"

The CodeIgniter routing system changed to handle the modules in URI. Also an additional route settings added to set default module.

For example this is the default "webapp/configs/routes.php" file of Arag project:

  $route['default_module']      = "arag";
  $route['default_controller']  = "arag";
  $route['scaffolding_trigger'] = "";

Above example will load Arag controller from Arag module, when module and controller names are not specified in URI.\\
There is also a private routing configuration file in each modules directory, which can contain each module's routing configurations. You can refer to the above diagram of modules structure, to see where you can find the private configuration files of each module.

In Arag a new method of routing system is implemented, by which, you can have a bunch of controllers - in your "controllers" directory of each module - that extend the main controller of that module. In this way you can break your controller into new ones which inherit the main controller, so that you will have a neat and more flexible code.\\ Imagine these scenario. You have a "backend.php" controller in the root of your controller directory. In this backend controller you have bunch of methods, from index to settings, list, create, edit and etc. Whenever you want to call one of these controllers you have to for example use this address: "<modulename>/backend/edit". At first sight it seems that it's much easier and simple, but if you think more you will understand that you have a thousand lines source code just for your backend. Besides implementing special features, like authorization, on each of your controller's methods individually,  will be so difficult. But if you break it into new controllers, like "settings.php" or "edit.php" which has their own constructor, "index_read" and "index_write" methods, all of these problems will be solved automatically. In this way, you can create a "tabbedblock" in your main controller's constructor and then share it with other controllers by making them extend it. Our new controllers directory will be something like this: 


  +-- webapp
       ...
       +-- modules
            +-- <module_name>
                   +-- config
                   +-- controllers
                   |     +-- backend
                   |     |   +-- backend.php
                   |     |   +-- edit.php
                   |     |   +-- settings.php
                   |     |
                   |     +-- frontend.php
                   | 
                   +-- locale
                   +-- models
                   +-- schemas
                   +-- templates
            
Just remember that doing this, you have to change your validation directory too. It means that every controller you have, should have it's own validation file, in it the associated directory. For more information about validations, refer to [[#form_validation|Form Validation]] section.

==== Database Schemes ====

Every module can have its own database schema with which you can create new tables with new entries. In this way you can revert to previous versions of your database schema any time it is needed. Schemes are located at "<moduleName>/schemas/<VersionNumber>/<ModuleName>.schema". There is also a "module.php" file for every module, which has information about the related module - such as schema version. This file is located at "<ModuleName>/config/module.php".\\
Now, lets take a look at how we should implement a schema. To create a schema, you have to use a script located at "etc/scripts", called "create_schema.php", as below:

  ./create_schema.php --dsn=mysql://<username>:<password>@<host>/<dbname> <ModuleName>/schemas/<VersionNumber>/<ModuleName>.schema

  ./create_schema.php --dsn=mysql://root:root@localhost/cms blog/schemas/v0.1/blog_entries.schema

To see how to create a schema you can read a schema's codes.

==== Models and Global Models ====

Models are exactly same as what they are in CodeIgniter, the only difference is the location of related files. In general, models are located at "webapp/modules/<module_name>/models/<model_name>.php".

You can load models in same way you do in CodeIgniter but it has some additional tricks:

  $this->load->model('ExampleModel');

This will load a model called ExampleModel in current module. But what if you want to specify a module name too? Just use an Array to specify the model and module name as following example:

  $this->load->model(Array('ExampleModel', 'ExampleModule'));

In both above examples if the called model doesn't exist, the loader will try to load a global model from "webapp/models/" directory. Simple, isn't it?!

==== Templates ====

Don't worry, there is nothing new here except that in Arag, "views" directory renamed to "templates", so that you can put Smarty template files there, too.

Lets have a closer look at it. For example you can have a file called "index.php" and another one "index.tpl" and simply load the view with following code:

  $this->load->view('index'); 

If Smarty integration is enabled in "arag_configs.php", loader will load "index.tpl" file otherwise it will load "index.php".
In ".tpl" files you can use Smarty templates engine language, Smarty plugins and helpers.

==== Global smarty plugins ====

In Arag project there is several smarty plugins located at "webapp/templates/smarty_plugins/". These plugins are loaded by default and are accessible in all smarty template files.

=== Blocks ===

"arag_block" is just Smarty block plugin to wrap contents. Blocks make templates much readable and flexibly in case of designing.

The following sample code shows how to use a block:

  {arag_block title="This is a test!"}
     {arag_block template="blank"}
        This is a default block wrapped in a blank block.
     {/arag_block}
  {/arag_block}

This code generates this XHTML: 

   <div class="arag_block" dir="ltr">
       <div class="arag_block_title">This is a test!</div>
       <div class="arag_block_content arag_tags_ds">
           <div class="arag_blank_block" dir="ltr">
               <div class="arag_blank_block_content arag_tags_ds">This is a default block wrapped in a blank block.</div> 
           </div>
       </div>
   </div>

As you can see blocks are much cleaner and flexible than plain XHTML. When you are using blocks, there is no difficulty to validate the xhtml markup or taking care of padding, margin and in other general design concepts of blocks.

Each block has two optional attribute. The first one is "title" which specifies title of block and "template" is the second one which specifies which template the block should use.

Possible templates which you can use are:

^ Template Name ^ Description ^
| arag_block | When "template" attribute was not specified this template will be used as default template |
| blank         | This templates create an blank block without any styles except that it taking care of padding |
| default       | This is default template of the application, beware that, this is not the default template when "template" attribute was not specified  |
| empty         | This is actually an empty block without any kind of style |
| error         | This is template for error messages |
| info          | This is template for info messages |
| warning       | This is template for warning messages |


You can find all the block templates at "webapp/templates/arag_blocks/<template_name>.tpl" and style sheet file of all blocks is located at "public_html/styles/styles.css".

You can simply add custom template for "arag_block" if it's needed. For more information check out one of existing templates .
If you are interested about arag_block plugin itself, it is accessible at "webapp/templates/smarty_plugins/block.arag_block.php"

=== Directions and Alignments ===

There are three plugins for working with direction and alignment of XHTML tags. These plugins return correct values depend on what language is selected and what its text direction is.

Following code shows how to use these plugins:

  <table border="0" dir="{dir}">
  <tr>
      <td align="{right}">_("Title"):</td>
      <td align="{left}">
          <input type="text" name="title" />
      </td>
  </tr>
  <!-- ... -->
  </table>

In above example, {dir} returns exactly the current language direction (for example ltr, rtl, etc.) and {right} or {left} returns alignment depends on the current language text direction. For example in ltr(left to right) direction, {right} will return 'right' (without quotes) and {left} will return 'left'(without quotes) if it was rtl.

Using these plugins, make templates flexible to different languages with different text directions.

=== Escape ===

"arag_escape" is a Smarty modifier and prefilter to convert all applicable characters to HTML entities; In general it escapes the output.

So when you are using a Smarty variable it will be escaped automatically. Following example shows what we are talking about:

  // Controller
  $this->load->vars('my_html_code', '<script language="javascript">alert('XSS');</script>');
  
  // Template
  {$my_html_code}
  
  // Expected output
  <script language="javascript">alert('XSS');</script> 

If you execute this example resulting in an unexpected output it shows that "arag_escape" modifier is not enabled. To solve the problem you should configure it in "arag_config.php" file.

Sometimes you don't want to escape a variable by default, so you can use following code in such cases:

 {$my_safe_html|smarty:nodefaults}

Also in some cases you might have to use "smarty:nodefaults", otherwise Smarty will throw a strange error. For example when you are using "isset" function in "if" statements:

  {if isset($my_var|smarty:nodefaults)}
     My var is defined.
  {/if}

=== Head ===

"arag_head" is also a Smarty function plugin which returns site's head contents.

You can see how to use it between "head" XHTML tags in the below:

  <html>
  <head>
       <title>Arag</title>
       {arag_head}
  </head>
  <body>
       <!-- ... -->
  </body>
  </html>

This plugin simply includes a template file located at "webapp/templates/arag_templates/head.tpl".

Following example is the default "head.tpl" file for Arag project:

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="icon" href="{$arag_base_url|smarty:nodefaults}/images/misc/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="{$arag_base_url|smarty:nodefaults}/images/misc/favicon.ico" type="image/x-icon" />
  <link rel="stylesheet" media="all" type="text/css" title="Arag" 
        href="{$arag_base_url|smarty:nodefaults}/styles/styles.css" />    

=== Form ===

This Smarty plugin will let you to put HTML forms into your Smarty templates:

  {arag_form uri="staticpages/backend/create" method="post"}
    HTML Form Elements
  {/arag_form}

The above code generates the following:

  <form actin="staticpages/backend/create"  method="post">
    HTML Form Elements
  </form>

If you don't send any method, by the default it will be post.

=== WISIWIG Editor ===

This is a functional Smarty plugin for adding a rich text editor - powered by FCKeditor - to your Smarty templates. You can use this plugin simply like the following example:

  {arag_rte name="Arag"}

This will give you an editor based on the default properties. But if you want to have a customized one you should use the attributes considered for this task as:

  {arag_rte name="Arag" value="Default text value going to be edited" height="450" width="75%" toolbar_set="Default"}

For more information about "toolbar_set" and other issues about editor, please refer to FCKeditor's official documentation.

=== Arag Validation ===

This plugin is for showing form validation error messages. It's almost like an Arag block:

  {arag_validation_errors}

For more information about the usage of this plugin and Arag's form validator refer to "[[#form_validation|Form Validation]]" section.

=== Asterisk ===

This plugin helps you to put a red asterisk into your templates (e.g. required fields in a from):

  {asterisk}

will generate:

  <span class="asterisk">&nbsp;*&nbsp;</span>

=== Quote ===

Some times you need nested quotes in your template. This block will help you to do that:

  <input type="submit" name="submit" value={quote}_("Yes"){/quote} />

which generates:

  <input type="submit" name="submit" value=\"_("yes")\" />

==== Decoration and Decorators ====

"Decoration and Decorators" is a new feature implemented in Arag project.

By this feature, any method in controller might have a decorator template. Following code shows how to use a decorator template to decorate a controller:

  // Controller
  function index()
  {
      $this->load->decorator('decorator');            
      $this->load->view('index');
  }
  
  // index.tpl
  <h3>This is index page</h3>
  
  // Decorator (decorate.tpl)
  <html>
  <head>
      <title>Arag</title>
      {arag_head}
  </head>
  <body>
      {slot name="content"}
  </body>
  </html>

With "slot", Smarty function plugin, you can fetch a specified slot's contents. For example in above example slot fetches a slot called "content", expected output of this line is "<h3>This is index page</h3>". 

"content" slot is a general slot and it contains requested method's contents. For example if requested URI is "blog/backend/index", it contains the index method from "backend" controller output.

To create a slot, you can simply call a method from controller as following example:

  // Controller
  function index()
  {
      $this->load->decorator('decorator');            
      $this->load->view('index');
      
      $this->post();
  }
  
  function post()
  {
      $this->load->view('post');
  }
  
  // post.tpl
  <h3>This is post page</h3>
  
  // Decorator (decorate.tpl)
  <html>
  <head>
      <title>Arag</title>
      {arag_head}
  </head>
  <body>
      {slot name="post"}
      {slot name="content"}
  </body>
  </html>

If your decorator template file is not located at "templates" directory of module then loader will try to fetch it from global templates directory at "webapp/templates/". So you can have a global decorator which will be accessible in all Smarty templates.

==== Helpers ====

When Smarty integration is enabled, helpers are not accessible in Smarty templates. But we can implement some Smarty plugins as wrappers between Smarty and helper functions in "webapp/helpers/<helper_name>" directory. We implemented some helper wrappers for you, so if you load a helper and it was accessible in Smarty templates, it shows it is implemented before, otherwise you have to write it yourself. Writing a wrapper is very simple. You can checkout "webapp/helpers/url/function.anchore.php" or any existing wrapper source code available at "webapp/helpers/" folder to understand "How to write a wrapper yourself in 24 seconds" :P.

Loading a wrapper is simply done when you load a helper as following:

  $this->load->helper('url');

And it will be accessible in Smarty templates as simple as writing (in this case we are using anchor wrapper):

  {anchor uri="example/test/sample_id"}

If Smarty throws an error you have to handle it yourself as described :).

==== Components ====

Component is a new feature implemented in Arag project which probably you are not familiar with it.

components are located at "webapp/components" directory and has a directory structure as following:

  +-- webapp
       ...
       +-- components
            +-- <component_name>
            |      +-- component
            |      |      +-- <component_name>.php
            |      |
            |      +-- plugins
            |      +-- templates
            |
            +-- <component_name2>
                   +-- component
                   |      +-- <component_name2>.php
                   |
                   +-- plugins
                   +-- templates

At the moment components are just accessible in Smarty templates, so you don't have any chance to use components when Smarty integration is disabled.
We don't have any plan to implement it for native template engine but it is not hard to do that.

Lets see how to load a component with an example:

  $this->load->component('MyComponent');

And it will be accessible in Smarty templates as following:
  
  {my_component attribute="hi"}

If you need to do something directly with a component itself, e.g. setting an option, you can do it like this:

  $this->MyComponent->setAnExampleOption('BlahBlah');

If you are confused don't worry we will explain how to use components with real world examples later.

=== PList Component ===

"PList" is a paginate list component. You can simply pass Array or any type of Iterator to it and it will generate a paginate list.

The following example shows how to create a simple list:

  // Controller
  $this->load->component('PList');
  $this->Plist->setResource(Array(Array('Brous', 'Willis'), Array('Tom', 'Cruise'), Array('John', 'Travolta')));
  $this->Plist->addColumn(0, 'Name');        
  $this->Plist->addColumn(1, 'Lastname');
  
  // Template
  {arag_plist}

"setResource" method used to specify our resource and "addColumn" used to create columns of the list.
"addColumn" simply used to specify what column we want to show and what label it should take.

and another example

  // Controller
  $this->load->model('BlogModel');
  $this->load->component('PList', 'BlogList');
  
  $this->BlogList->setResource($this->BlogModel->getEntries());
  $this->BlogList->setLimit(4);
  $this->BlogList->addColumn('subject', 'Subject');        
  $this->BlogList->addColumn('author', 'Author');
  $this->BlogList->addColumn('BlogModel.getDate', 'Create Date', PList::VIRTUAL_COLUMN);
  $this->BlogList->addAction('blog/backend/edit/#id#', 'Edit', 'edit_action', 'BlogModel.editIsDisble');
  $this->BlogList->addAction('blog/backend/delete/#id#', 'Delete');
  
  // Template 
  {arag_plist name="BlogList"}

We passed an additional parameter to "load->component" to make a custom name for our list. This feature is useful when you want to use more than one "PList" in a single template file.

As you probably guessed "setLimit" used to set number of rows which should be shown in the list. If number of records is greater than our limit, "Plist" will use paginate to provide access to other pages and actually paginate our list.

In third "addColumn" method you can see how to create virtual columns. Virtual columns are used to show additional columns which are not in resource it self.
Every virtual column is simply a callback and it called with passed current row data. 
In above example "BlogMode.getDate" is a virtual column callback. The following code shows "getDate" method of "BlogModel" model.

  class BlogModel extends Model 
  {
      // ...
      
      function getDate($row)
      {
          return date('Y-m-d H:i:s', $row['create_date']);
      }
  }
 
Lets try to explain how it works. When "Plist" reaches a virtual column in its columns list, it tries to call the virtual column callback. For example in above sample, "PList" will call "getDate" method from "BlogModel" model for each row of the list. "getDate" in each call, takes a parameter that is the current row content in which "PList" iterator is in; Then it uses that parameter to format a Unix timestamp to a human readable date string.

Long story short, in general, returned content of a virtual column will be presented exactly in current row of the list.

Following table shows possible formats of virtual column callback names:

^ Callback                     ^ Description ^
| <model_name>.<callback_name> | Will call "callback_name" method from "model_name" model | 
| <class_name>::<method_name>  | Will call "method_name" static method from "class_name" class |
| <method_name>                | Will call "method_name" method from specified resource (In case of the resource was Iterator) |

Now lets create a directory listing from "/tmp" directory:

  // Controller
  $this->load->component('PList', 'directory');
  $this->directory->setResource(new RecursiveDirectoryIterator('/tmp'));
  $this->directory->setLimit(4);
  $this->directory->addColumn('Directory');
  $this->directory->addColumn('getOwner', 'Owner', PList::VIRTUAL_COLUMN);
  $this->directory->addColumn('getGroup', 'Group', PList::VIRTUAL_COLUMN);
  $this->directory->addColumn('getSize', 'Size', PList::VIRTUAL_COLUMN);
  
  // Template
  {arag_plist name="directory"}

As you probably guessed "getOwner", "getGroup" and "getSize" methods belongs to "RecursiveDirectoryIterator" object.

There is an optional attribute for "arag_plist" plugin called "template". You can specify a custom template for list, following example shows how to use this feature.

  {arag_plist template="my_custom_template"}

You can put your custom template file (in this case "my_custom_template.tpl") in your module "templates/" directory or in "components/plist/templates" directory if you want it become accessible from everywhere.

For more information about how to write a custom template for "Plist" you can checkout "Plist" default template file located at "components/plist/templates/horizontal.tpl".

If you are interested about callable methods of "PList" component which you can use, please check out "components/plist/component/plist.php".

With Arag "Plist", it is also possible to add group actions to your list. So that you give your list the ability of doing an action on more than one item of your list simultaneously. To add a group action to you list you should use the following syntax in which, the first parameter is the URL of the action, the second is the title and the third one specifies the icon which the action uses:

  $this->staticpages->addAction('staticpages/backend/gdelete', 'Delete', 'delete_action', PList::GROUP_ACTION);

=== TabbedBlock Component ===

"TabbedBlock" is a component for creating tabs. Following example shows you how to create tabs with "TabbedBlock" component:

  // Controller
  $this->TabbedBlock->setTitle('Hello');
  $this->TabbedBlock->addItem('Index', 'blog/backend/index');
  $this->TabbedBlock->addItem('Post', 'blog/backend/post');
  $this->TabbedBlock->addItem('Arag', 'arag/');

  // Template
  {arag_tabbed_block}
     
     <h3>This is content of tabbed block</h3>  
      
  {/arag_tabbed_block}
 
As you saw you can simply add items or tabs to "TabbedBlock" component with "addItem" method. You can also set title of "TabbedBlock" with "setTitle" method.

If you want to share a "TabbedBlock" component between a controller's methods you can simply put it in the constructor of the controller as following example:

  class ExampleCtrl extends Arag_Controller {
  
      function ExampleCtrl()
      {
          parent::Arag_Controller();
    
          $this->TabbedBlock->setTitle('ExampleCtrl');
          $this->TabbedBlock->addItem('Index', 'blog/examplectrl/index');
          $this->TabbedBlock->addItem('Post', 'blog/examplectrl/create');
      }
  
      function index()
      {
          // ...
      }
  
      function create()
      {
          // ...
      }
  }

There is an optional attribute for "arag_tabbed_block" plugin called "template". With this attribute you can specify a custom template for your "TabbedBlock". following example shows you how to use this feature:

  {arag_tabbed_block template="my_custom_template"}

You should put your custom template file (in this case "my_custom_template.tpl") in your module "templates/" directory or in "components/tabbedblock/tempates" directory if you want it becomes accessible from everywhere.

For more information about how to write a custom template for "TabbedBlock" you can checkout "TabbedBlock" default template file located at "components/tabbedblock/templates/arag_tabbed_block.tpl".

If you are interested about callable methods of "TabbedBlock" component which you can use, please check out "components/tabbedblock/component/tabbedblock.php".

Arag tabbedblock has also a feature wich lets you to add sub tabs to your top tabs. Imagine that you have TabbedBlock containing "List" and "Create". In "List" you have a list of your objects with actions of "Edit" and "Delete. Now you want to add sub tabs "Edit" and "Delete" every time user clicks on "List". For doing that you should use the following code:

  $this->load->component('TabbedBlock', 'global_tabs');
  $this->global_tabs->setTitle(_("StaticPages"));
  $this->global_tabs->addItem(_("List"), 'staticpages/backend/index');
  $this->global_tabs->addItem(_("Create"), 'staticpages/backend/create');
  $this->global_tabs->addItem(_("Edit"), 'staticpages/backend/edit/%id%', 'staticpages/backend/index');
  $this->global_tabs->addItem(_("Delete"), 'staticpages/backend/delete/%id%', 'staticpages/backend/index');

As you see, "addItem" can take a third parameter in which you can define this item is the sub tab of the tab which its address is "staticpages/backend/index".

==== I18N ====

Internationalization is a method for supporting international languages in Arag. Actually it is a extended library depending on CI and PHP's "gettext". Using this library will let you have different linguistic versions of Arag. Adding this feature to your modules is very simple. You just have to add a new directory to your modules directory named "locale". In "locale" directory you have to add your desired language systems such as en_US.utf8, fa_IR.utf8 and ... and then in each of your language system's directories, a "LC_MESSAGES" directory for storing '.po' (Portable Object) and '.mo' (Machine Object) messages to include your translations. You can see the structure of a "locale" directory in the following diagram:

  +-- (Module Name)
      +-- config
      +-- controllers
      +-- locale
          +-- fa_IR.utf8
              +-- LC_MESSAGES
      +-- models
      +-- schemas
      +-- templates

After adding mentioned directories to your modules then you have to make a '.po' message from all of your strings, using a shield script called "extract_gettext.sh" located in "etc/scripts. But remember before doing that you have to put all of your strings (which you want to be translated), in your source, in a _(" "), so that the script would be able to recognize them. You can see some examples below:

  $this->tabBock->addItem(_("List"));

  {capture assign="msg"}_("Do you really want to delete '%s'?"){/capture}

  <input type="submit" name="submit" value={quote}_("No"){/quote} />

After running the script and generating ".po" files, you have to compile them to ".mo" files (readable by the application) using the "format_gettext.sh" script located in the same place.
But lets take a closer look at this procedure. "extract_gettext.sh" actually fetch all the strings marked by _(" ") in your source code and add them to a ".po" file. ".po" extensions are very easy to modify, so even someone without any knowledge of programming can simply add translations of the extracted strings to the ".po" files. In the next step, "format_gettext.sh" will compile those ".po"s to ".mo" files. Notice that you have to recompile ".po" files every time that you modify them.

There are some important notes about using the I18N:
  * Before using I18N you have to reconfigure your locale with and add your desired language system like this:
     #dpkg-reconfigure locales
  * You also have to reconfigure the config file - "config/arag_config.php".
  * If you can't see your translations, first check the code, then empty your cache in "cache/smart_compile/", restart your apache server and check again.
  *  If there have been any problem with your coding or the language system you are using, or even if you don't use the I18N at all, the application will automatically use the pure strings in the _(" ") by the default language system configured at your config file.

==== Arag Libraries ====

There are several libraries in Arag project which each of them extends some libraries from CodeIgniter. In the lake of API documentation of implemented features, this directory is a good place to start with.

Currently there are several libraries in Arags project listed below:

^ Library            ^ Extends      ^
| Arag_Controller | Controller   |
| Arag_Loader     | Loader       |
| Arag_Output     | Output       |
| Arag_Router     | Router       |
| Arag_Smarty     |      -       |
| Components         |      -       |
| Arag            |      -       |

Arag ("Arag.php") is what called "CodeIgniter.php" in CodeIgniter libraries directory.

Components and "Arag_Smarty" are implemented for Arag project and those not have parent class in CodeIgniter.


==== Benchmark ====

|               ^ RPS (Enabled caching) ^       RPS      ^
^ Arag (ESI) |          77.56        |      26.93     |   
^ Arag       |          78.02        |      39.58     |  
^ CodeIgniter   |          84.17        |      47.52     |
| ESI: Enabled Smarty integration |||

==== Form Validation ====

This feature will help you to validate your forms according to your own rules definitions. Arag's "Form Validation" is based on CI form validator library, but it is much more comprehensive and easier to implement than the CI's form validator. It lets you to check filled forms for errors and repopulate them very easily. In CI, as you know, you had to set rules every time you called form validation library, but in Arag, every controller of a module has it's own global sets of rules located at "<module name>/validator/<controller>.php". This file consists of some arrays for setting rules and fields.\\
Just like CI you have to set rules for every form you have, except that here you just set them in an array and pass them to your validator of the relative method. Like the following example:

  $_rules = Array (
                    'subject' => 'trim|required|alpha_numeric',
                    'page'    => 'required|xss_clean',
                  );

  $validator['create']['write']['rules'] = $_rules;

You also have to set Fields for repopulating:

  $_fields = Array (
                    'subject' => 'Subject', 
                    'page'    => 'Page'
                   );
  $validator['create']['write']['fields'] = $_fields;

And error messages that have to be shown in case of error occurring (according to your rules):

  $validator['error_messages'] = Array (
                                        'required'   => '%s is required.',
                                       );

For more informations about CI rules and their jobs take a look at CI official documentation.\\
Now in you main controller you have to add a error method in which, if error occured it will let the job continues, else, it will do what you put in the method:

    function create_write_error()
    {   
        $this->create_read();
    }

What we have done until know was the backend of your form validation. But to make it enable in your Smarty template you have to change your template.\\ First you have to use a plugin for showing error messages:

  {arag_validation_errors}

And adding values to your form elements for enabling repopulating:

  {arag_rte name="page" value=$page|smarty:nodefaults}

  
  <input type="text" name="subject" value="{$subject}" />

And now it's done!!\\ \\ 
Arag's form validation also supports validating of data passing through URL. In this case you can check if the correct data is passed or not. For example you want to pass a page's id for editing through address bar. So you use "<controller>/edit/<id>". Arag Form Validation, helps you to check the existence of the given id, take numeric ids and etc. It's almost same as post method, except that you give segment number (starting from 1) instead of field name:

  $validator['edit']['read']['fields'] = array (1 => "ID");
  $validator['edit']['read']['rules']  = array (1 => "required");

and in your controller backend:

  function edit_read_error()
  {
    Statement;
  }

In the above example, "1" is segment number one in the URL after "edit". Like "<controller>/edit/**23**".

==== Invalid Request Page ====

This page contains an error block and a return link, for showing in cases in which user has an invalid request. Imagine these scenario that user pass an ID through URL. But the ID doesn't exist. So you can handle the error with Arag form validation and redirect user to the invalid request page using the following code:

  $this->_invalid_request("staticpages/backend/index");

The parameter which we sent is the address of the return link.
